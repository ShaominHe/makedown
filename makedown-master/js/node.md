## node

### 简介

node框架比较特殊：
js的组成：ECMAScript、BOM、DOM
浏览器为什么能解析js代码，因为在浏览器中有一个js引擎，这个引擎能解析ECMAScript
DOM和BOM的解析依赖于浏览器本身
将浏览器中的引擎，拿出来做了一个软件就是node
以前的js依赖于浏览器才能运行，有了node以后，js代码不用依赖浏览器也能运行，只要在电报上安装这个软件就行，js代码特质ECMAScript
有了node，js不在是单纯的写前端，还可以写后端---node可以当做一门服务器语言

node.js运行代码有两种方式：
1、直接在命令行，输入：node命令
			进入了代码编辑：写ECMAScript的代码，敲回车就能运行---相当于在浏览器的控制台写代码运行
2、写一个js文件，里面写一些ECMAScript的代码
			在命令行中输入：node文件的路径  敲回车也能运行，直接运行的整个文件

### 简单的命令

```
盘符：		#进入某个盘符
cd 目录   #进入某个目录
cd ..     #回到上一级目录
dir		#查看当前文件夹中的文件和文件夹
tree # 查看当前文件夹中的所有文件和文件夹包括子文件夹及其文件，树状结构
cls # 清屏
ipconfig # 查看当前电脑的网管信息
systeminfo # 查看当前电脑的配置信息
md 文件夹名 # 新建文件夹    make dir   directory
rd 文件夹名 # 删除文件夹
xcopy 文件夹 新文件夹名 # 复制文件夹，并起新的名字
type nul> 文件名 # 新建文件
copy 文件名 新文件名 # 复制文件，并起新的名字
echo 内容 > 文件名 # 给文件中写入内容
move 文件路径 新的路径 # 将文件移动到新的路径
ren 文件名 新的文件名 # 将文件重命名
del 文件名 # 删除一个文件
```

在vscode中，自带了命令行，可以直接在编辑器中执行命令

```
ctrl+`		#打开编辑器的命令行
或者在文件上点击“用命令打开”
```



### 导入导出

导出：
每个文件都有一个对象：module。这个对象中有一个属性叫做exports,也是一个对象。当前文件导出的内容写在这个对象中

```
module={
	exports:{
		name:"张三"
	}
}
```

这个对象是默认存在的，不需要重新赋值

```
module.exports.name="张三"
module.exports.age=20
```

导入：
将另一个文件中导出的内容接受起来

```
var res = require(要导入的文件)	//如果是相对路径，不能省略，返回值就是别人导出的exports那个对象
```



### 内置模块

#### fs模块

导入文件，node中内置了很多文件，可以导入进来使用
导入进来能使用的文件叫做模块，就是一个写好的文件

```
var fs = require("fs")
```



##### 写入文件

###### 异步写入

fs.writeFile(文件路径，写入的数据，[编码]，写入完成后执行的回调函数)

使用说明：
1、文件存在则写入，文件不存在则创建文件写入
2、文件中没内容就直接写，有内容会**覆盖**写入

```
var fs =require("fs")
fs.writeFile("./test.txt","hellow node","utf-8",function(err){
	if(err){
		console.log("写入失败")
	}else{
		console.log("写入成功")
	}
})
```

###### 同步写入

fs.writeFileSync(文件路径，写入的数据，[编码])

```
var fs =require("fs")
fs.writeFileSync("./test.txt","hellow node"})
```



##### 读取文件

###### 异步读取

fs.readFile(文件路径，[编码]，读取结束后的返回函数)
读取错误的时候，err是错误信息，读取成功的时候，err是undefined

```
fs.readFile("./a.txt",function(err,data){
	if(!err){
		console.log(data)	//没有错误，说明读取成功了，打印读取出来的数据
	}
})
```

###### 同步读取

fs.readFileSync(文件路径，[读取文件的编码])

```
var fs=require("fs")
var data=fs.readFileSync("./a.txt")
```



##### http模块

node做后端需要依赖一个模块叫做http
引入模块：

```
var http = require("http")
```

利用这个模块做服务器

```
http.creatServer(function(req,res){
	//处理客户端的请求
	console.log("有请求")
	console.log(req)	//response包含了所有的请求的信息，请求行，请求头，请求空行，请求主体
	console.log(res)	//request是服务器给客户端响应的信息，可以自己设置
})
//监听端口
server.listen({
	host:"localhost",
	port:9988,
})
```

启动文件，服务器就启动了，一直在启动状态，等待客户端请求进来

创建服务器的回调函数有两个参数：参数1是请求的信息，参数2是响应信息
响应信息可以自己设置

```
res.write(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体
res.end();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。
res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()
res.statusCode: 响应的的状态码 200 404 500
res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。不能赋值中文
res.setHeader(name, value); 设置响应头信息， 比如content-type
res.writeHead(statusCode, [statusMessage], [options]); 设置响应头，同时可以设置状态码和状态信息。
```

<font color="red">**注意：必须先设置状态码，再设置响应头，最后设置响应主体，顺序不能乱。** </font>



##### 自定义模块

自己写的文件做导入导出

##### 第三方模块

使用npm下载

##### npm

第三方模块是别人写好的一些文件，我们要使用这些文件，就需要下载
node 提供了一个工具，叫做npm，专门用来管理这些模块。可以下载，可以更新。。。npm除了可以管理第三方模块，还可以管理一些框架，插件和库。所以npm叫做包管理器，我们将模块，插件，库，框架统称为包

npm这个工具在安装node的时候会自带npm

 npm可以连接到各个插件、框架、模块、库的下载地址，

下载命令：

```
npm  install  包名    #下载一个包
```

下载完成后，会在当前文件夹中新建一个文件叫`node_modules`，将下载好的模块放到这个文件夹中，还会生成一个文件叫做package.json里面放的是下载的模块的信息

可以简写：

```
npm i 包名
```

指定版本下载

```
npm i 包名@版本号
```

使用说明：
1、`install`关键字可以简写为`i`
2、默认下载的是最新版本，要下载指定版本可以在包名后面加@版本号
3、可以同时下载多个包，多个包名中间用**空格**隔开
4、每次下载会自动生成一个文件：`package-lock.json`，里面下载的各种信息，

卸载包

```
npm uninstall 包名
```

`package.json`这个文件用来描述当前项目的各种信息。通常一个项目中会使用到很多的包、库、模块、插件等等，到项目完成的时候，`node_modules`这个文件夹会很大，如果要上线了或者要放到别的地方运行，将这个文件夹复制的话，会很大，容易造成文件夹的丢失。解决这个问题可以使用`package.json`。在这个文件夹中可以将项目依赖的包的信息，写进去，以后别人拿到这个文件就能知道，这个项目依赖的包有哪些

如何使用这个文件：

```
npm  init
```

命令执行后，需要根据提示输入项目的信息
如果不想输入很多的信息，可以全部使用默认值

```
npm  init  	-y
```

<font color=red>如果要是用默认的话，当前文件夹名不能是中文</font>

有了这个文件后，在下载包的话，文件中就会添加依赖的包的信息

```
{
  "name": "03-npm",  //描述了包的名字，不能有中文
  "version": "1.0.0",  //描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。
  "description": "", //包的描述信息
  "main": "index.js", //入口文件（模块化加载规则的时候详细的讲）
  "scripts": {  //配置一些脚本，在vue的时候会用到，现在体会不到
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],  //关键字（方便搜索）
  "author": "",  //作者的信息
  "license": "ISC",  //许可证，开源协议
  "dependencies": {   //重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项
    "bootstrap": "^3.3.7",
    "jquery": "^3.3.1"
  }
}
```

**别人拿到这个文件，只需要执行命令就可以将项目依赖的包都下载下来，不需要一个一个对着下**

```
npm	 i
```

如果安装失败，或者不想要了，可以通过以下命令清除npm缓存：

```
npm  cache  clean  -f  //-f强制清除
#或者直接将缓存文件夹删除
```

上面安装的包，都是只能在当前文件夹使用，如果讲项目文件放到别的地方，就找不到安装的依赖包了，我们将这种安装方式叫做局部安装。

**全局安装**：只需要在电脑上安装一次，在电脑的任何地方都能使用。
局部安装只是在当前文件夹中安装，全局安装时安装在当前电脑上

全局安装命令：

```
npm	install	--global  包名
npm	install	-g	包名
```



##### nrm

npm在下载包的时候，默认下载地址在国外，有时候网速不好，所以node提供了一个工具来管理npm下载工具，可以改变npm的下载地址，这个工具就是nrm
nrm这个工具不自带，需要手动下载安装：

```
npm  i  -g  nrm
```

检测是否安装成功：

```
nrm  --version
```

nrm 的使用：

```
nrm  test  #用来检测哪个地址下载速度快一些，当前使用地址前面会带*
```

现在有很多网站，将常用的工具放上去，供人们下载，我们将这些网址叫做镜像源。测试出来的结果：镜像源名称-----网速，我们挑选网速最快的镜像源地址使用：

```
nrm   use  taobao    #将下载地址换成taobao的镜像源
```

