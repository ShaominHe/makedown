#### 生命周期

从vue实例创建到销毁

项目是从创建到版本结束

### 复习：

jsonp只能通过get,而ajax可以get 、post、 delete、 put

1、vue特点：

双向绑定，虚拟DOM

2、事件：

​	1、事件的值可以是一个函数

​			1、函数带括号，可以传值，但是事件对象不会传递。$event

​			2、函数不带括号，默认传递的是事件对象

​			修饰符

​					.stop:阻止冒泡

​					.prevent:阻止默认事件

​					.a    .65   :键盘事件相关

​	2、事件的值也可以使JS语句

3、指令

4、侦听和计算属性

如何定义，如何使用，两者的区别

5、过滤器

局部  	 	全局

filters    	Vue.filter

如何定义如何使用
参数：第一个 参数是你要过滤的值，结果是返回的值，第二个参数开始是你要传的值

6、es6

如何导入
如何导出

### 组件

##### 静态组件

之前的自定义组件

##### 动态组件

可以根据is属性来决定该组件的具体值
后期路由可以用它实现

```
<components is=></components>    也是内置组件
```

组件传值

1、组件父子传值（向下，父级向子级传）
	属性
2、组件子父传值（向上，子级向父级传）
	1、事件：将方法以属性的方式向下传，然后在组件当中调用该函数，并传值

​	2、自定义事件
​	@abcdefg="函数"
​	子组件当中
​	this.$emit('abcdefg',参数1，参数2......)

3、非父子
	bus     $emit    $on  

$emit:触发自定义的事件
$on:用于定义自定义的事件
		$on("定义的事件名","函数")
		$emit("事件名",1,2,3) 
$emit与$on需要在相同得到实例当中

组件之间的数据不是共享的，
组件之间可以传值，组件传值是单向数据流，并且传过来的值是只读的，不允许直接修改
子组件接收的属性名不允许与你的数据状态相同

组件向下传值：

```
<body>
    <div id="wrap">
        <Child :num="age"></Child>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
            age:11
        },
        methods:{

        },
        components:{
            Child:{
                // data(){
                //     return{
                //         age:10
                //     }
                // },
                props:["num"],  //用来接收值
                template:`<div>我还是一个孩子，我今年{{num}}岁了</div>`
            }
        }
    })
```

组件向上传值：

```
<body>
    <div id="wrap">
        <input type="button" @click="age++" value="加1">
        <Child :num="age" :change-age="changeAge"></Child>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
            age:11
        },
        methods:{
            changeAge(n){    //通过方法向上传值
                this.age+=n
            }
        },
        components:{
            Child:{
                props:["num","changeAge"],
                template:`<div><input type="button" value="加2" @click="changeAge(2)">{{num}}</div>`
            }
        }
    })
```

自定义组件：

```
<body>
    <div id="wrap">
        <input type="button" value="显示与隐藏" @click="isShow=!isShow">
        <My v-if="isShow" @abcdefg="changeShow"></My>   
        <!-- 自定义组件 -->
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
            isShow:true
        },
        methods:{
            changeShow(bol){
                this.isShow=bol
            }
        },
        components:{
            My:{
                template:`<div style="background:red;width:300px;height:300px">
                        <input type="button" value="隐藏" @click="$emit('abcdefg',false)">
                </div>`   
                //自定义组件通过$emit触发  第一个参数是你自定义的组件，第二个以后的都是你要传的值
            }
        }
    })
```

###### 

###### $emit和$on

```
<body>
    <div id="wrap">
        <input type="button" value="执行" @click="$emit('one',5,6,7)">
        <input type="button" value="执行1" @click="sendOne">
        <!-- 点击执行结果是one 5 6 7 two,点击执行1结果是one 1 2 3 two  -->
        <My></My>
    </div>
</body>
<script type="text/javascript">
//如何定义（$on）,如何调用（$emit）。$on与$emit要在相同的vue实例中
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{
            sendOne(){        //也可以通过方法来触发,也可以传参数
                this.$emit("one",1,2,3)
            }
        },
        mounted(){
            console.log(123)
            this.$on("one",function(a,b,c){
                console.log("one",a,b,c)
            })
            this.$on("one",function(){       //不会覆盖
                console.log("two")
            })
        },
        components:{
            My:{
                mounted(){
                    this.$on("one",function(a,b,c){
                        console.log(a,b,c)
                    })
                },
                template:`<input type="button" value="执行3" @click="$emit('one',1,1,1)">`
            }
        }
    })
</script>
```

###### bus

第一种：

```
<body>
    <div id="wrap">
        <!-- <input type="button" value="点击" @click="$emit('one',1,2,3)">   直接调用调用不到，因为不是同一个实例 -->
        <!-- 但是可以通过函数调用 -->
        <input type="button" value="点击" @click="sendOne">    
    </div>
</body>
<script type="text/javascript">
const bus=new Vue();
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{
            sendOne(){
                bus.$emit('one',1,2,3)
            }
        },
        components:{
            
        },
        mounted(){
            bus.$on("one",function(a,b,c){
                console.log(a,b,c)
            })
        }
    })
</script>
```

第二种：

```
<body>
    <div id="wrap">
        <!-- <input type="button" value="点击" @click="$emit('one',1,2,3)">   直接调用调用不到，因为不是同一个实例 -->
        <!-- 但是可以通过函数调用 -->
        <input type="button" value="点击" @click="sendOne">    
        <input type="button" value="点击1" @click="$bus.$emit('one',7,8,9)">    
        <one></one>
    </div>
</body>
<script type="text/javascript">
    Vue.prototype.$bus=new Vue();
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{
            sendOne(){
                this.$bus.$emit('one',1,2,3)
            }
        },
        components:{
            One:{
                components:{
                    Child:{
                        template:`<div><input type="button" value="点击3" @click="$bus.$emit('one',4,7,8)"></div>`
                    }
                },
                template:`<div>
                    <input type="button" value="点击2" @click="$bus.$emit('one',6,9,0)">
                    <child></child>
                    </div>`
            }
        },
        mounted(){
            this.$bus.$on("one",function(a,b,c){
                console.log(a,b,c)
            })
        }
    })
</script>
```

###### $once和$off

```
$once:通过该方法定义的事件，只会被执行一次
$off：关闭（移除）指定的事件

$off

<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{

        },
        mounted(){
            //挂在完毕之后，vue自动执行
            this.$on("one",function(){
                console.log(123)
                this.$off("one")   //移除自定义事件
            })
        }
    })
    
    
$once

<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{

        },
        mounted(){
            //挂在完毕之后，vue自动执行
            this.$once("one",function(){
                console.log(123)    //自定义事件只会被执行一次
            })
            this.$on("one",function(){
                console.log(123)
                this.$off("one")   //移除自定义事件
            })
        }
    })
```

###### $nextTick

```
在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中

```

###### 全局组件

```
全局组件只是定义的方式，作用的范围不相同，其他的都一样
Vue.component("One",function(){
	props:[]
	data(){
		return{
		
		}
	},
	template:``
})
```

##### 补充

```
props:["a"]    //用来接收值
props是组件中用来接受向下传递的值的，但是如果没有传值的话，接受会报错所以
props:{
	a:{
		default:100    //设置默认值
		type:Number    //设置数据类型
	}
}
props设置数组没有默认值也不可以设置数据类型
props设置为对象，可以限制数据类型，以及设置默认值
```

##### 钩子函数

mounted

```
mounted(){
	//Vue生命周期，vue实例从创建到销毁的过程，在该生命周期当中所暴露出来的函数，称为钩子函数
	//当你的挂载元素加载完毕之后执行，钩子函数
}
```

### ref

ref：是元素的属性，它要与$refs结合使用

1、与DOM元素结合使用
	在DOM元素当中增加ref属性并且给予该属性值，可以通过this.$refs.ref的属性值  可以得到该DOM元素

```
得到Input用value，得到div等用InnerText
<body>
    <div id="wrap">
        <div ref="myDiv">啊啊啊</div>
        <input ref="userName" type="text"><input type="button" @click="subFn" value="提交">
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        methods:{
            subFn(){
                console.log(this.$refs.myDiv.innerText)
                console.log(document.querySelector("input[type=text]").value)
                console.log(this.$refs.userName.value)
            }
        },
    })
</script>
```

如果有多个DOM元素，他们的ref的属性名都相同那么得到的是最后一个

```
<body>
    <div id="wrap">
        <div ref="myDiv">123</div>
        <div ref="myDiv">456</div>
        <input type="button" @click="subFn" value="提交">
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        methods:{
            subFn(){
            //结果输出456
                console.log(this.$refs.myDiv.innerText)
            }
        },
    })
</script>
```

2、与v-for结合使用

```
<body>
    <div id="wrap">
        <input type="button" value="点我吧" @click="fn">
        <div v-for="item in num" :key="item" ref="myDiv">{{item}}</div>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data:{
            num:10
        },
        methods:{
            fn(){
                // console.log(this.$refs.myDiv.innerText)   //会报错
                this.$refs.myDiv.forEach(v=>{   //可以得到每一个元素的值
                    console.log(v.innerText)
                })
            }
        },
    })
</script>
```

3、与组件结合使用

```
通过this.$refs.ref的属性名，得到的是你组件的实例，通过还实例可以操作组件内部的属性与方法

<body>
    <div id="wrap">
        <input type="button" value="点击" @click="fn">
        <My ref="com"></My>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{
            fn(){
                // console.log(this.$refs.com)//就是组件
                // console.log(this.$refs.com.num)  //10
                // this.refs.com.num++    //可以更改组件的内容
                this.$refs.com.myFn(this.$refs.com)//可以传值给组件当中的函数
            }
        },
        components:{
            My:{
                data(){
                    return {
                        num:10
                    }
                },
                methods:{
                    myFn(com){
                        console.log(1111111,this===com)
                    }
                },
                template:`<div>{{num}}</div>`
            }
        }
    })
</script>
```

### 插槽slot

slot可以将组件元素所包裹的内容进行渲染。slot组件是内置组件

匿名插槽：
没有定义名字，插槽可以将组件元素当中的组件不包含slot属性的元素进行渲染

```
<body>
    <div id="wrap">
        <My><div>啊啊啊啊啊啊啊啊啊啊啊</div></My>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{

        },
        components:{
            My:{
                template:`<div>my
                        <slot></slot>
                        <slot></slot> //可以出来两个
                    </div>`
            }
        }
    })
</script>
```

具名插槽：
slot拥有name属性，他会将组件元素当中的slot属性值与slot属性值相同的元素进行渲染

```
<body>
    <div id="wrap">
        <My>
            <div slot="s1">啊啊啊啊啊啊啊啊啊啊啊</div>
        </My>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{

        },
        components:{
            My:{
                template:`<div>my
                        <slot name="s1"></slot>
                    </div>`
            }
        }
    })
</script>
```

插槽作用域

```
在组件当中可以通过slot-scope属性得到slot当中除了name以外的所有属性
<body>
    <div id="wrap">
        <My>
            <div slot="s1" slot-scope="data">啊啊啊{{data}}</div>   //得到slot的除了name的所有属性
        </My>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
        },
        methods:{

        },
        components:{
            My:{
                data(){
                    return{
                        userName:"张三"
                    }
                },
                template:`<div>my
                        <slot name="s1" age="12" :user-name="userName"></slot>
                    </div>`
            }
        }
    })
</script>

```

### sync

修饰符sync：向下传值的同时，会创建一个自定义事件，事件的名字为update:属性名

```
向下传递了一个Num属性，自定义了一个事件，事件的名字为update:num,当该事件被触发后会执行n=>num=n
<My :num="num" @update:num="n=>num=n"></My>
向下传递一个Num属性，可以在My组件当中通过$emit('update:num',100),将父级的num修改为100
简写形式
<My :num.sync="num"></My>
```

### VM实例

```
<body> 
         <!-- 可以在外面修改里面的值 -->
    <input type="button" value="修改" onclick="changeNum()"> 
    <div id="wrap">
        {{num}}
    </div>
</body>
<script type="text/javascript">
    const vm = new Vue({
        el: "#wrap",
        data: {
            num:1
        },
        methods: {
            fn() {
                console.log(vm===this)     //this与vm的引用地址相同
                //这里的this就是vue实例就是vm
            }
        },
    })
    // console.log(vm)   //得到的就是vue实例
    // console.log(vm.fn())  //可以在外部调用vm下面的东西
    // function changeNum(){
    //     vm.num=100      //可以在外面修改里面的值
    // }
    function changeNum(){
        vm.fn(vm)    
    }
</script>
```

##### $data

vm.$data是与vue配置项data是相同的

```
<body>
    <div id="wrap">
        <input type="text" v-model="num">
        {{num}} | {{$data.num}}
    </div>
</body>
<script>
const data={
    num:2
}
    const vm=new Vue({
        el: "#wrap",
        data,
        // data: {
        //     num:1
        // },
        // mounted(){
             // console.log(this.num,this.$data.num) //都是1
        // }
    })
    // console.log(vm.num,vm.$data.num)//都是1
    console.log(vm.$data===data)   
</script>
```

##### $options

```
<body>
    <div id="wrap">
        {{num}} | {{$options.lalala}}
        <!-- 加$options可以获取自定义属性 -->
    </div>
</body>
<script>
    new Vue({
        el: "#wrap",
        data: {
            num:111
        },
        lalala:"xixi"
    })
</script>
```

##### $mount

```
<body>
    <div id="wrap">
        {{num}}
    </div>
</body>
<script type="text/javascript">
    const vm=new Vue({
        // el: "#wrap",
        data: {
            num:10
        },
    })
    vm.$mount("#wrap")
</script>
```

手动挂载的两种写法

```
<body>
    <input type="button" value="挂载元素" onclick="fn()">
    <div id="wrap">
        {{num}}
    </div>
</body>
<script type="text/javascript">
//正常写法
    // const vm=new Vue({
    //     // el: "#wrap",
    //     data: {
    //         num:10
    //     },
    // })
    // // vm.$mount("#wrap")
    // function fn(){
    //     vm.$mount("#wrap")
    // }
//连缀写法
 const vm=new Vue({
     data:{
         num:10
     }
 }).$mount("#wrap")
</script>
```

如果手动挂载和el挂载都有的话，el的优先级高

##### $el

```
<body>
    <input type="button" value="修改样式" onclick="changeStyle()">
    <div id="wrap">
        {{num}}
    </div>
</body>
<script type="text/javascript">
    const vm = new Vue({
        el: "#wrap",
        data:{
            num:1
        }
    })
    console.log(vm.$el)   //指的是你挂载的元素
    console.log(vm.$el===document.querySelector("#wrap"))   //true
    function changeStyle(){
        vm.$el.style.background="red"
    }
</scri
```

##### $refs

```
<body>
    <div id="wrap">
        <div ref="myDiv">123</div>
    </div>
</body>
<script type="text/javascript">
    const vm=new Vue({
        el: "#wrap",
    })
    console.log(vm.$refs.myDiv.innerText)
</script>
```

### 自定义指令

#### 局部指令

```
<body>
    <div id="wrap">
        <div v-red>红</div>
        <div v-green>绿</div>
        <div v-color="yellow">黄</div>
        <div v-color="'blue'">蓝</div>
        <My></My>
    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data:{
            yellow:"yellow"
        },
        components:{
            My:{   
                template:`
                    <div>
                        <div v-red>啊啊啊</div>    
                    </div>
                `
                //v-red会报错，因为组件是独立的，用不到外面的东西，所以需要定义全局的自定义指令,第二个参数是接收的值
            }
        },
        directives:{
            red(el){
                el.style.color="red"
            },
            green(el){
                el.style.color="green"
            },
            color(el,bind){
                el.style.color=bind.value
            }
        }
    })
</script>
```

#### 全局指令

vue.directive(指令的名字，function(el,bind){

​	el:指令所在的元素
​	bind.value:  接收的值

})	

```
<body>
    <div id="wrap">
        <div v-red>红</div>
        <div v-green>绿</div>
        <div v-color="yellow">黄</div>
        <div v-color="'blue'">蓝</div>
        <My></My>
    </div>
</body>
<script type="text/javascript">
    Vue.directive("red", function (el) {
        el.style.color = "red"
    }),
    Vue.directive("green", function (el) {
        el.style.color = "green"
    }),
    Vue.directive("color", function (el, bind) {
        el.style.color = bind.value
    })
    new Vue({
        el: "#wrap",
        data: {
            yellow: "yellow"
        },
        components: {
            My: {
                template: `
                    <div>
                        <div v-red>啊啊啊</div>    
                    </div>
                `
            }
        }
    })
</script>
```

如果要传多个值的话，可以传一个对象

```
<body>
    <div id="wrap">
        <div v-color="{color:'yellow',background:'red'}">啊啊啊</div>
    </div>
</body>
<script type="text/javascript">
    Vue.directive("color", function (el, bind) {
        el.style.color = bind.value.color;
        el.style.background = bind.value.background;
    })
    new Vue({
        el: "#wrap",
    })
</script>
```

$nextTick

```
<body>
    <div id="wrap">
        <input type="button" :value="age" @click="changeAge">

    </div>
</body>
<script type="text/javascript">
    new Vue({
        el: "#wrap",
        data: {
            age: 12
        },
        methods: {
            changeAge(e) {
                this.age++
                //vue
                console.log(this.age, e.target.value, document.querySelector("#wrap input").value)   //结果是13,12,12
                this.$nextTick(() => {
                    console.log(this.age, e.target.value, document.querySelector("#wrap input").value)   //结果是13,13,13
                })
            }
        },
    })
</script>
```



### MVC

是一种架构思想，编程思想

### 补充：

```
const obj = {
    a:1
}
const obj2 = {
    b:2
}
assign:第一个参数是目标对象，后面的所有参数是源对象。
该方法将源对象合并到目标对象当中，然后将目标对象进行返回
const obj3 = Object.assign(obj,obj2);
console.log(obj === obj3);
```

