### 路由

大组件写在view里，小的写在components里，路由写在rouder里

如果你的地址后面输入不正确会指向到main.js中挂载的页面位置
只能在开发环境中使用，如果打包之后就修改就不起作用了

vue-router:

#### 内置组件

1、router-link：提供链接，可以让路由在不同组件之间切换
to:实现跳转
如： 
	<router-link to="/">Home</router-link>|
      <router-link to="/about">About</router-link>|
      <router-link to="/my">My</router-link>

2、router-view：显示路由相对应的组件。给你的路由组件进行了一个占位。
<router-view name="One"></router-view>

<router-view name="Two"></router-view>

<router-view name="Three"></router-view>

#### 代码

```
const routes = [
  {
  	//路径
    path: '/',  
    //根据该属性，可以知道你在使用哪一个路由，组件
    name: 'home',
    //当访问地址与path相匹配话，会将该组件替换router-view这个标签
    component: Home
  },
 ]
```

例：

```

也可以将nav放到外部

<template>
  <div id="app">
    <!-- 将nav也放到外部 -->
    <MyNav></MyNav>    
    <router-view/>
  </div>
</template>

<script>
export default {
  components:{
    MyNav:()=>import("./components/MyNav")
  }
}
</script>


外部nav


<template>
    <div id="nav">
      <router-link to="/">Home</router-link>|
      <router-link to="/about">About</router-link>|
      <router-link to="/my">My</router-link>
    </div>
</template>

<script>
export default {
  name: "my-nav"
};
</script>

<style scoped>
</style>
```

##### 1、模式

```
	1、history
	2、hash
```

##### 2、引入组件

```
写法两种：
1、
import One from '../views/One';
{
	path:"/one",
	component:One
}
2、
{
	path:"/one",
	component:()=>import("../views/One")
}
```

##### 3、设置404，

当找不到匹配路由时会使用该路由

```
 {
       path: '*',
    component: () => import("@/components/Error")
   },
```

##### 4、起别名alias

```
    {
       // 路径
       path: '/',
       // 根据该属性，可以知道你在使用哪一个路由，组件
       name: 'home',
       alias: "/home",// 可以通过/home访问该路由。相当于给了该路由两个入口
       // 当访问地址与path相匹配的话，会将该组件替换router-view这个标签。
       component: Home
   },
```

##### 5、重定向redirect：

将当前匹配的地址，跳转到另外一个地址。

```
 {
       // 当你的地址为lala时，跳转到地址/my
        path:"/lala",
        redirect:"/my"
 },
```

##### 6、单页面多路由  

路由：

```
{
	 path: "/text",

    components:{

     	 //默认指向的组件
      	default: () => import("@/components/Four"),

      	//One将会覆盖App.vue中name为One的router-view的标签
      	One: () => import("@/components/One"),

     	//Two将会覆盖App.vue中name为Two的router-view的标签    	
      	Two: () => import("@/components/Two"),

     	//Three将会覆盖App.vue中name为Three的router-view的标签
    	 Three: () => import("@/components/Three")

   	 }

  },
```

使用时： 

```
<router-view/>

<hr>

<router-view name="One"></router-view>

<router-view name="Two"></router-view>

<router-view name="Three"></router-view>
```

#### 路由的传值

##### 1、query

​		1、如何传
传对象to前要加冒号

```
<div>
	<router-link to="/detail?id=1&type=2">图书1</router-link>|
	<router-link :to="{path:'/detail',query:{id:2,type:45}}">图书2</router-link>|
	<router-link :to="{path:'/detail?type:45',query:{id:2}}">图书2</router-link>|
	<router-link :to="{name:'detail',query:{id:3,type:35}}">图书3</router-link>|
</div>
```

​		2、如何接收

```
this.$route.query.id			this.$route.query.type
```

优点：刷新数据不会丢失

缺点：如果传递的是个对象的话，可以传过去，但是刷新页面，接受的对象会变为原始值

```
如果传过去的是个对象
<router-link :to="{name:'detail',query:{id:{a:1,b:2},type:35}}">图书3</router-link>|
```

##### 2、params

params刷新页面丢失，在做后台管理的时候，

当想要刷新将内容初始化的时候选择params

params传值

```
$router.push({name:'shopList',params:{shopTypeId:scope.row._id}})
```

接受params

```
this.$route.params.shopTypeId
```

​		1、如何传----写path不起作用，需要用name传

```
<div>
	写path不起作用，需要用name传
	<router-link :to="{path:'/detail',params:{id:1}}">图书1</router-link>
	<router-link :to="{name:'/detail',params:{id:2,type:2}}">图书2</router-link>
</div>
```

​		2、如何接收

```
this.$route.params.id			this.$route.params.type
```

优点：可以传递对象
缺点：刷新数据丢失

##### 3、设置路由

​		1、将路由进行设置

```
  {
    path:"/detail/:id",
    name:"detail",
    component:()=>import("@/views/book/detail")
    meta:{
    	//存储自定义的信息
    	authorization:false,  //设置权限，如果值为true验证,false不验证
    	isNav:true   //是否显示底部导航
    }
  },
```

​		2、如何传

```
<div>
	<router-link to="/detail/1">图书1<router-link>	<router-link to="'/detail/'+id">图书2<router-link>
```

​	3、	如何接收

```
this.$route.params.id	
```

特点：
不能直接传递对象，刷新数据不会丢失

#### 编程式导航

编程式导航可以处理逻辑问题
$router和$route,一个时路由器、一个路由

this.$router.push

```
this.$router.push("/my");
this.$router.push("/my?a=1&b=2");
this.$router.push({path:"/my",query:{c:3,d:4}});
this.$router.push({name:"/my",query:{c:3,d:4}});
<input type="button" @click="$router.go(-1)" value="返回">
```

#### 路由守卫（路由拦截）

1、组件内部守卫
	beforeRouteEnter:    进入路由之前

​	beforeRouteUpdate:	更新当前路由参数之前

当你不改变路由地址的时候，生命周期当中的挂载阶段不会再次执行

​	beforeRouteLeave:		离开路由之前

```
 export default {
        name:"my",
        data(){
          return {
              isLogin:true
          }  
        },
        //从from路由进入到to路由
        //to是要进入的路由，from是来自哪个路由，next是一个函数,是否允许进入
        beforeRouteEnter(to,from,next){
            console.log(to,from)
            console.log(this.isLogin)  //这里的this是undefined因为在进来之前，还没有实例化
            if(true){
                next()   
            }else{
                next(true)  //值可以为一个布尔值，默认为true，
                next({path:"/Order"})
                next({name:"Order"})
            }
        },
        //to是要去哪，from是当前的组件，next是否允许离开
		beforeRouteLeave(to,from,next){
			console.log(to,from)
		},
		beforeRouteUpdate(to,from,next){
			console.log(to,from)
		}
    }

```

2、全局守卫

//全局前置守卫

​	beforeEach((to,from,next)=>{});

//全局后置守卫，没有next

​	afterEach((to,fromt)=>{});

//全局解析守卫：当你某一个组件有单独的验证，在全局当中还要有其他的验证

​	beforeResolve((to,from,next)=>{})

3、路由独享

beforeEnter()